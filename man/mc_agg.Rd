% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/agg.R
\name{mc_agg}
\alias{mc_agg}
\title{Aggregate data by function}
\usage{
mc_agg(
  data,
  fun = NULL,
  period = NULL,
  use_utc = TRUE,
  percentiles = NULL,
  na.rm = TRUE,
  custom_start = NULL,
  custom_end = NULL,
  custom_functions = NULL
)
}
\arguments{
\item{data}{cleaned myClim object in Prep-format: output of \code{\link[=mc_prep_clean]{mc_prep_clean()}} or Calc-format as it is allowed to aggregate data multiple times.}

\item{fun}{aggregation function; one of (\code{"min"}, \code{"max"}, \code{"mean"}, \code{"percentile"}, \code{"sum"}, \code{"range"}, \code{"count"}, \code{"coverage"})
and functions defined in \code{custom_functions}. See details by custom_functions argument.
Can be single function name, character vector of function names or named list of vector function names.
Named list of functions allows apply different function(s) for different sensors e.g. \code{list(TMS_T1=c("max", "min"), TMS_T2="mean", TMS_T3_GDD="sum")}
if NULL records are not aggregated, but converted to Calc-format. See details.}

\item{period}{Time period for aggregation - same as breaks in cut.POSIXt, e.g. (\code{"hour"}, \code{"day"}, \code{"month"}); if NULL then no aggregation

There are special periods \code{"all"} and \code{"custom"}. Period \code{"all"} returning single value for each sensor based
on function applied across all records within the sensor. E.g. mean and max air temperature from all data from the logger.
Period \code{"custom"} aggregates data in year time window. You can aggregate e.g. water year, vegetation season etc by providing start, end datetime.
See \code{custom_start} and \code{custom_end} parameters. The output of special periods \code{"all"} and \code{"custom"}is not allowed to be aggregated
again in \code{\link[=mc_agg]{mc_agg()}} function.

Start day of week is Monday.}

\item{use_utc}{default TRUE, if set FALSE forced to use UTC time, instead possibly available time offset
(in locality metadata: tz_offset) local or solar time see (e.g. \code{\link[=mc_prep_solar_tz]{mc_prep_solar_tz()}}, \code{\link[=mc_prep_meta_locality]{mc_prep_meta_locality()}});
Non-UTC time can by used only for period \code{day} and longer.}

\item{percentiles}{vector of percentile numbers; numbers are from range 0-100; each specified percentile number generate new sensor, see details}

\item{na.rm}{parameter for aggregation function; Not used for count and coverage. special importance for period \code{"all"} and \code{"custom"} see details}

\item{custom_start}{date of start only use for \code{custom} period (defaul NULL); Character in format \code{"mm-dd"} or \code{"mm-dd H:MM"}.}

\item{custom_end}{date of end only use for \code{custom} period (defaul NULL); If NULL then calculates in year cycle ending on \code{custom_start} next year.
If parameter is filled in then data out of range \code{custom_start}-\code{custom_end} are skipped. E.g. vegetation season, winter season...
Character in format \code{"mm-dd"} or \code{"mm-dd H:MM"}. \code{custom_end} row is not included. I.e.complete daily data from year 2020 ends in 2021-01-01 \code{custom_end="01-01"}.}

\item{custom_functions}{user define one or more functions in format \code{list(function_name=function(values){...})}; then you will feed function_name(s)
you defined to the \code{fun} parameter. e.g. custom_functions = list(positive_count=function(x){length(x\link{x>0})}),
fun="positive_count",}
}
\value{
Returns new myClim object in Calc-format see \link{myClim-package} ready for \code{mc_calc} functions family. When fun=NULL, period=NULL
records are not modified but only converted to Calc-format. When fun and period provided then time step is aggregated based on function.
}
\description{
Function has two basic uses:
\itemize{
\item aggregate (upscale) time step of microclimatic records with specified function (e. g. 15 min records to daily means);
\item convert myClim object from Prep-format to Calc-format see \link{myClim-package} without records modification, this behavior appears wen fun=NULL, period=NULL.
}
}
\details{
Any output of mc_agg is in Calc-format. That means the structure of myClim object is flattened.
Hierarchical level of logger is removed (Locality<-Logger<-Sensor<-Record), and all microclimatic records within
the sensors are joined directly to the level of locality (Locality<-Sensor<-Record).
This is called Calc-format and is only acceptable format for \code{mc_calc} functions family. See \link{myClim-package}.

In case \code{mc_agg()} is used only for conversion from Prep-format to Calc-format (fun=NULL, period=NULL) then microclimatic
records are not modified. Equal step in all sensors is required for conversion from Prep-format to Calc-format.

When fun and period is specified, microclimatic records are aggregated based on function into new period.
Aggregated time step is marked by a first time step of selected period i.e. day = c(2022-12-29 00:00, 2022-12-30 00:00...);
week = c(2022-12-19 00:00, 2022-12-28 00:00...); month = c(2022-11-01 00:00, 2022-12-01 00:00...);
year = c(2021-01-01 00:00, 2022-01-01 00:00...).
When first or last period is incomplete in original data, the incomplete part is deleted, and a warning is shown
(e.g. when original data starting on 2021-11-28 00:00 and period = ”month” then incomplete November is deleted
and aggregation starts in December).

The behavior is a bit diferent for special period \code{"all"}. Incomplete datetime series aren't
deleted, but result of aggregation depends on \code{na.rm} parameter. If \code{na.rm=T} then returns value even in case you have only few records out of 365 days.
CAUTION! \code{na.rm=T} is default. If \code{na.rm=F} returns NA when missing data occures.

Empty sensors with no records are excluded. \code{mc_agg()} return NA for empty vector except from count which returns 0.
When aggregation functions are provided as vector or list e.g. c(mean, min, max), than they are applied to all sensors
of input myClim object. When named list (names are the sensor ids) of functions is provided then \code{mc_agg()}
apply specific functions to the specific sensors based on the named list.
Aggregation function creates new sensors on localities putting aggregation
function in its name (TMS_T1 -> TMS_T1_max), despite sensor names contains aggregation
function, sensor_id stays the same as before aggregation in sensor metadata (e.g. TMS_T1).
Sensors created with functions \code{min}, \code{max}, \code{mean}, \code{percentile}, \code{sum}, \code{range}
keeps identical sensor_id and value_type as original input sensors.
When function \code{sum} is applied on \code{logical} sensor (e.g. snow as TRUE, FALSE) the
output is  \code{integer} i.e. number of \code{TRUE} values.

Sensors created with functions \code{count} has sensor_id \code{count} and value_type \code{integer},
function  \code{coverage} has sensor_id \code{coverage} and value_type \code{real}

Read carefully details about \code{sum} and \code{count} these two may not be intuitive.
}
\examples{
hour_data <- mc_agg(mc_data_example_clean, c("min", "max", "percentile"), "hour", percentiles = 50, na.rm=TRUE)
day_data <- mc_agg(mc_data_example_clean, list(TMS_T1=c("max", "min"), TMS_T2="mean"), "day", na.rm=FALSE)
}
